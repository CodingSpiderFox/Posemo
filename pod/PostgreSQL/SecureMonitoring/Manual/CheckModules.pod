=encoding utf8

=head1 Posemo Developer Manual: Check Modules

This manual is about writing check modules for Posemo. This documentation is work in 
progress â€“ if you miss something, L<open a issue at GitHub|https://github.com/alvar-freude/Posemo/issues/new> 
or L<write me a mail|mailto:alvar@a-blast.org>.


=head2 Overview

Writing check modules is simple and easy. Often you only have to wrinte some
SQL, define the return type and the Posemo sugar makes everything else for you.

Each check generates a PostgreSQL function, which encapsulates your code. 
You can write the check in every L<proceducal language|https://www.postgresql.org/docs/current/static/xplang.html>, 
default is simply L<SQL|https://www.postgresql.org/docs/current/static/xfunc-sql.html>.

Since Posemo is written in fully OO-Perl with L<Moose|Moose>, you usually has
full access to all Moose features. For most checks, you don't need to write Perl code, only SQL.

Each check module is a subclass of L<PostgreSQL::SecureMonitoring::Checks|PostgreSQL::SecureMonitoring::Checks>
and you can override each method or add something with all Moose method modifiers. e.g. when
you want to change the ebhaviour of the C<ececute> method.

Each check module should return generic values, independently from the frontend.


=head2 Examples

You can use all the check modules in C<lib/PostgreSQL/SecureMonitoring/Checks> as examples.


=head3 Simple Example

A minimalistic check module looks like this:

   package PostgreSQL::SecureMonitoring::Checks::SimpleAlive; # by Default, the name of the check is build from this package name 
   
   use PostgreSQL::SecureMonitoring::ChecksHelper;            # enables Moose, exports sugar functions; enables strict&warnings
   extends "PostgreSQL::SecureMonitoring::Checks";            # We extend our base class ::Checks
   
   check_has code => "SELECT true";                           # This is our check SQL!
   
   1;                                                         # every Perl module must return (end with) a true value


So, in the first line there is the name of the Perl package. As usual, this B<must>
be the same as the file and path name, but with C<::> instead of C</> and
without the file extension.

In line 3, the module uses the Posemo Checks helper module. This enables
everything from L<Moose|Moose> (including L<strict|strict> and L<warnings|warnings>!), 
like you type C<use Moose;>, and one additional sugar function with 
the name C<check_has>. With this you can set every attribute
of the base class C<PostgreSQL::SecureMonitoring::Checks>. See below for a list
of all attributes.

In line 4, C<PostgreSQL::SecureMonitoring::Checks> is defined via Moose as base
class, our module inherits everything from that. See the L<Moose::Manual|Moose Manual>
for more documentation about moose.

In line 6, all check parameters are defined. The only parameter (which must be
set by every check module) is the code. If you have a very special case, you might
want to override the C<_build_code> method instead.


=head3 Example with return type

The following example is from the C<Slave Lag> check. Here in this documentation only 
the C<check_has> command is mentioned (see above for everything around or the real code 
for full file with user documentation):

   check_has
      description => 'When the server is a slave, then return the replication lag in seconds.',
      return_type => 'double precision',
      result_unit => 's',
      code        => "SELECT CASE WHEN pg_is_in_recovery()
                                  THEN extract(EPOCH FROM clock_timestamp() - pg_last_xact_replay_timestamp()) 
                                  ELSE NULL
                                  END 
                             AS backup_age;";

Here you can see, that there are more attributes beside the C<code> are defined: 

C<description> is a short description of the check. Each check should have a description!

C<return_type> defines the return type of the SQL function. This is passed directly to 
PostgreSQL and is also the default C<result_type>.

C<result_init> is forwarded to the frontend via the output module as is. It should be displayed in the frontend.

C<Code> is as usual the SQL for the check. Each column (here: only one) should have a name, which 
is displayed by the frontend. 




=head2 Attributes

C<check_has> accepts a lot of attributes:

=over 4



=back



=head2 Return values

=head3 Recommended return values

Your check can theoretical return every value(s) you can imagine. It's possible to
return complex things with a JSON data structure or something else. B<Don't do this!>

B<Your return values should be generic and usable by every frontend.> You should not
return a result like C<critical> by your check SQL itself, because it usually don't
know the thresholds etc. Instead, use the buildin C<test_critical_warning> method
or write your own and override it. If you want to return a list of texts
(e.g. "unused indexes") beside a counter, you should override the C<execude> method,
change the result and set the C<message> inside the result in C<test_critical_warning>.




=cut
